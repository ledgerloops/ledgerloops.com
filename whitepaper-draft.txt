OpenTabs: Second-order promise loops

Introduction to promise loops
=============================
If everybody would only look after their own needs, the world would be a lot less efficient. It's often
useful if one person performs a task that benefits a different person. For instance, you can cook for me,
or I can fix your bicycle. A society in which everybody cooperates altruistically is hard to keep together,
because if some people only consume and don't contribute, they can easily destablize such a cooperating
society. To avoid that, apart from exchanging neutral information about what activities are needed and who
plans to do what, we can exchange promises.

A promise is a statement that has a more complex social function than simply the exchange of information.
For instance, if you say to you "You will cook for me", that sounds very different from you yourself saying
"I will cook for you". The first may in some cultures be acceptable as a command from a boss to a worker, or from a parent to
a child. The second is not a command, because you yourself make a statement about what you will do. This
statement can turn out to be true or false, but since we both automatically interpret it as a promise,
your reputation will be damaged if you don't attempt to make the statement true, that is, I will trust you
to keep your promise, or at least to try to do so.

When interpreting your promise, I can take into account several factors:

* your ethics (that is, you are not a mean person who tries to achieve personal gain by making empty promises),
* your intelligence and mental sanity (that is, you know what you're saying, speak out of your own free will,
and are unlikely to later forget what you promised),
* the difficulty of the task you promise to perform (whether you promise to do the impossible),
* related to that, your skill and ability to successfully complete the task (that is, you know how to cook,
have access to the necessary ingredients and tools, etc.),
* your reputation risk (that is, even if your ethics are questionable, or unknown to me, I can trust that you
will keep your promise based on social connections we share, and who would like you less if they found out you
made an empty promise to me),
* your third-party punishment risk (you could be arrested and punished by some government authority or mafia boss if they
notice you making empty promises to people they protect),
* your second-party retalliation risk (I could personally have more or less opportunity to punish you myself),

and probably maybe some other factors. Making a promise creates a debt, and there is always a risk in counting
on someone to keep their promise and to resolve this debt. In order to mitigate some of these risks, you and I can make
promises that are not absolute, but only applicable if some conditions are true. For instance, you could promise
"I will cook for you, if you fix my bicycle". If I then also promise "I will fix your bicycle if you will cook for me",
then we have the opportunity to barter. Once we both made our conditional promise, we can trigger both of them into
action by agreeing to both go ahead and perform the task we mentioned. Ideally, to minimize the risk even more for both
of us, we could perform our tasks at the same time, so that I can see you are at least starting to cook, and you can see I'm
starting to work on your bicycle. If, after a short time, one of us would stop investing effort in our task, then the other
person would notice, ask what the reason is, and renegotiate the barter. If we both invest into our cooperation bit-by-bit,
instead of making a big investment upfront, our exposure to the risk of the other person not keeping their promise is also
smaller.

If barter is not possible (for instance, if your bicycle is not currently broken), we can use debt to still achieve a deal
that is fair (you cook for me today because you know it will make me remember my debt when the time comes that you ask me
to fix your bicycle). If debt-based cooperation is not possible, (for instance, we're only meeting briefly and will likely return
to being strangers soon), we can use money. If you are a restaurant owner, and your bicycle is not currently broken, I might
promise to pay you in commodity money (like gold), or fiat money (like bank notes). We can also use virtual money, which is
neither commodity that has intrinsic value, nor fiat backed by a government, but instead is backed by a community of people
who happen to use this money as currency (like bitcoin or bank-of-time).

Another option, if your bicycle is not broken, but you do need a haircut, and we can find a hairdresser with a broken bicycle,
would be group barter: we agree that you cook for me, I fix the hairdresser's bicycle, and the hairdresser
cuts your hair, and all three of us gain something that is of more value to us than the effort we invest in the task we
perform for the next person in the loop. In a graph:


    your promise      > my promise                   > hairdresser's promise
          |          /      |                       /          |
          v         /       v                      /           v
    you cook for me     I fix hairdresser's bicycle     you get a haircut

In this graph, your promise creates a debt, my promise is conditional on you keeping your promise, and forwards the debt
to the hairdresser. The hairdresser then cuts your hair to eliminate the debt.

But in practice, we will probably go through three phases of discussion before we reach this group barter deal. First,
we search for people to barter with (let's call this the search phase). Once you, me, and the hairdresser found each
other, we each make our conditional promise (let's call this the negotiation phase):
* You promise to cook for me if you get a haircut from the hairdresser
* I promise to fix the hairdresser's bicycle if you cook for me
* The hairdresser promises to cut your hair if I fix their bicycle

The three conditional promises form a three-step loop in the way they refer to each other. Let's call this a
"first-order promise loop" for reasons that will become clear soon.

At this point, we can all see that there is an opportunity for cooperation, and we might negotiate exchange rates to make
the deal as fair as possible for everybody involved, adjusting maybe the amount of food you promise to cook, stating more
precisely which defects of the bicycle I promise fix, and which type of haircut you will get. Once we all agree that the
deal is fair, we can move on to the execution phase.

Ideally, we all start at the same time, so that no person needs to take more risk than the others, but this may not always be
practical (especially the combination of cooking food and getting a haircut at the same time!). This means one person (let's
call this person the "starter") needs to convert their conditional promise into an absolute promise, thereby forcing the
next promise to become absolute as well. As a logical rule of inference on the contents of my promise:
   
* I promised to:  [fix the hairdresser's bicycle] if you cook for me
* And given that:                                    You cook for me
* Conclusion:     --------------------------------------------------- +
* I should now:   [fix the hairdresser's bicycle]

But now we can notice a problem with using first-order promise loops for organizing cooperation: you may have only just
met this hairdresser, and once you cook, you now have a double risk of not obtaining your haircut: either I fail to
keep my promise, or the hairdresser fails to keep theirs. For very long first-order promise loops, the likelyhood that,
somewhere along the line, someone fails to deliver on their promise, becomes very high. Second-order
promise loops address this problem.

Second-order promise loops
==========================

After understanding the above introduction to first-order promise loops, the idea behind second-order promise loops is
in itself quite simple. The search phase is the same - you and me and the hairdresser somehow need to discover
each other, and each other's needs. But the negotiation phase is different.
Remember that in the negotiation phase for the first-order promise loop, we made the following promises:

* You promise to [[cook for me] if [you get a haircut from the hairdresser]]
* I promise to [[fix the hairdresser's bicycle] if [you cook for me]]
* The hairdresser promises to [[cut your hair] if [I fix their bicycle]]

In a second-order promise loop, we don't make our promises conditional on the other participants
*keeping* their promise, but on the other participants merely *making* their promise:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

After this negotiation phase, where we all establish and communicate our conditional promises, we can move on to the commitment
phase, where one person (the "committer") converts their conditional promise to an absolute one. Before moving on to the
execution phase, where you would actually start to cook, you first announce your decision to us that you will do so. That means
we now have one absolute promise (from you) and two conditional ones (from me and from the hairdresser):

* You promise to [cook for me]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

Now, regardless of whether you actually keep your promise, we can already apply inference to the other two promises:

* I promised to:                      [fix the hairdresser's bicycle] if [you promise to [cook for me]]
* And given that:                                                        You promised to [cook for me]
* Conclusion:                         ----------------------------------------------------------------- +
* I should now:                       [fix the hairdresser's bicycle]
* Also, the hairdresser promised to:  [cut your hair] if [I promise to [fix their bicycle]]
* And because:                                            I should now [fix their bicycle]
* Conclusion:                         ---------------------------------------------------- +
* The hairdresser should now:         [cut your hair]

The term "second-order" refers to the fact that promises are conditional on promises, so instead of one layer of promises on top
of statements about reality, we now have promises on top of promises (let us know if you can think of a better name for this!).

The advantage of second-order promise loops over first-order promise loops is, in terms of this example, that you can now claim
your haircut, even if the hairdresser's bicycle remains broken.

Promise loops and debt
======================
If you and I know each other, we don't have to settle each value exchange every time, you can just cook for me spontaneously,
and we'll both remember that debt.
This allows for a much more liquid cooperation - as long as you and I have some way to remember the contents of our private
ledger of debts between the two of us, we don't have to search for promise loops every time we want to do something for the
other person.

As long as we take care that your debt to me stays roughly equal to my debt to you (don't let the balance between us become
too uneven), we probably trust each other enough to take the risk that the other person takes off without ever repaying their
debt.
So instead of finding a hairdresser with a broken bicycle, you could say "I promise to cook for you", and I could say "If you
cook for me, then I will owe you something of comparable value", basically paying you for the cooking with an IOU note (short
for "I owe you"), signed by me.
Since it's only you and me involved, there's no need for second-order promises, a simple ledger for writing down debts will do
just fine. But the shortcoming of a two-party debt ledger is, of course, that you may want to collaborate with other specialists
(like hairdressers) to obtain the things you need. And if I owe you a debt, that does not enable you to get a haircut.

So a better way to use second-order promise loops is to combine it with peer-to-peer debt ledgers:
We write all debts in our ledger whenever one of us does something for the other person, and each of us could also have private
peer-to-peer debt ledgers with other people, with whom we interact in the same way. This means that the group barter process can
be entirely asynchronous from the actual commercial activity it negotiates. This is also where the name OpenTabs comes from:
people keep a tab open (like a tab in a bar), and given a network of such open tabs, the OpenTabs protocol allows participants
to search, negotiate, commit, and execute second-order promise loops that act like settlements to resolve or decrease the
outstanding amounts of debt on each ledger.

Comparison between OpenTabs and Money
=====================================
As an OpenTabs user, you can convert your credit with people who owe you a favor, to obtain things you need from other people.
This means that using OpenTabs will feel like what we know as money and you could define peer-to-peer debts as some sort of
one-time coin that gets anonymized into a different currency every time it passes to the next person, but such an abstract
description probably doesn't help a lot to make the process more intuitive.

Money (whether commodity, fiat, or virtual) has two important features which peer-to-peer debts and promise loops don't:
* as long as the community using the currency in question doesn't collapse, you're pretty sure that your money will keep its
value, in the sense that, in the future there will probably be someone who will be happy to accept your money in return for
something valuable.
* for many types of money, especially cash, you don't have to reveal information about where you got the money in order to use
the money. Even when paying by creditcard in a restaurant, the restaurant owner will not discover how the money got into your
bank account (although of course your bank will). Bitcoin does not have this feature, but since for many wallets it's not
publically known which real-world person this wallet belongs to, and it's not necessary to reveal this if you're careful,
a high level of obfuscation can still be achieved there as well.

Unlike money, OpenTabs does not form a bubble that can burst.
In OpenTabs, the ability to find useful promise loops grows with the network size of people actively looking for such promise
loops, with the number of connections between them, and with the frequency with which users put their activities and
peer-to-peer debts up for barter.
However, and this may seem unintuitive, OpenTabs usage can safely die and be revived in other places. It can be used in
several communities around the globe, which may stay disconnected from each other, become connected, and become disconnected
again, without risk of devaluation of people's outstanding credits and debts. This is because there is no central currency
or "bubble" of trust in the community (or its government) paying you back in the future.
At any time, you can only owe debt to your direct peers, and only they can owe debts to you. If someone defaults on their
debt, they only hurt their direct contacts, not the other participants in the network (remember that second-order promises
will still hold, even if the first-order promise they are based on is not kept).
Another way of seeing this is to say that OpenTabs is not a form of money, it is a ledger federation protocol.

This does leave us with one important shortcoming of second-order money loops: privacy. Let's see if we can improve the
system described so far by being more careful in what personal information you and I reveal to this hairdresser person.

Keeping our details more private
================================
Remember that in the process described so far, you, me, and the hairdresser engaged in a group conversation about the
following set of conditional promises:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

Instead of making these statements in one group conversation, we can also make them in three private conversations:

* Between you and me, conversation "YM"
  * Let's refer to "cook for me" as task "YM-1"
  * You promise to [[perform task "YM-1"] if [the hairdresser promises to [perform task "YH-1"]]]
  * I promise to [[perform task "HM-1"] if [you promise to [perform task "YM-1"]]]

* Between you and the hairdresser, conversation "YH"
  * Let's refer to "cut your hair" as task "YH-1"
  * You promise to [[perform task "YM-1"] if [the hairdresser promises to [perform task "YH-1"]]]
  * The hairdresser promises to [[perform task "YH-1"] if [I promise to [perform task "HM-1"]]]

* Between the hairdresser and me, conversation "HM"
  * Let's refer to "fix the hairdresser's bicycle" as task "HM-1"
  * The hairdresser promises to [[perform task "YH-1"] if [I promise to [perform task "HM-1"]]]
  * I promise to [[perform task "HM-1"] if [the you-person promises to [perform task "YM-1"]]]

Since you participate in both conversation "YM" and conversation "YH", you now have all the same information as in the
group conversation case, except for the nature of task "HM-1". Likewise I have all the same information except for the
nature of task "YH-1", and the hairdresser can compose all information they need to get their bike fixed in exchange
for giving you a haircut, without knowing that "YM-1" stands for you cooking me a meal. So having three separate
conversations instead of one group conversation is an improvement in terms of implementation. But we can, and should,
do better than that.

Suppose there is a fourth person involved, and the second-order promise loops looks like this:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the neighbor's bicycle] if [you promise to [cook for me]]]
* The neighbor promises to [[pay the hairdresser 10 US dollars] if [I promise to [fix their bicycle]]]
* The hairdresser promises to [[cut your hair] if [the neighbor promises to [pay them 10 US dollars]]]

We can now create four conversations, hiding even more information that does not need to be shared with the whole list
of participants:

* Between you and me, conversation "YM"
  * Let's refer to "cook for me" as task "YM-1", to me as "the M-person", and to you as "the Y-person"
  * The Y-person promises to [[perform task "YM-1"] if [the H-person promises to [perform task "YH-1"]]]
  * The M-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]

* Between you and the hairdresser, conversation "YH"
  * Let's refer to "cut your hair" as task "YH-1", to you as "the Y-person", and to the hairdresser as "the H-person"
  * The Y-person promises to [[perform task "YM-1"] if [the H-person promises to [perform task "YH-1"]]]
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]

* Between the hairdresser and the neighbor, conversation "HN"
  * Let's refer to "pay 10 US dollars" as task "HN-1", to the hairdresser as "the H-person", and to the neighbor as "the N-person"
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  * The N-person promises to [[perform task "HN-1"] if [the M-person promises to [perform task "NM-1"]]]

* Between the neighbor and me, conversation "NM"
  * Let's refer to "fix the neighbor's bicycle" as task "NM-1", to me as "the M-person", and to the neighbor as "the N-person"
  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The M-person promises to [[perform task "NM-1"] if [the Y-person promises to [perform task "YM-1"]]]

Now some more information is hidden from you, so what you see is this:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[perform task "NM-1"] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [the N-person promises to [perform task "HN-1"]]]

You can no longer see if a promise loop exists or not. But each participant can see that a partial loop exists,
and inform one of their peers about this. The neighbor, after talking both to me and to the hairdresser, could make
the following local inference:

  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The H-person promises to [[perform task "YH-1"] if [The M-person promises to [perform task "NM-1"]]]

In a graph:

   ???  -YM-1->  M  -MN-1->  N  -HM-1->  H  -YH-1->  ???

becomes:

   ???  -YM-1->  M  --------MN-1-------> H  -YH-1->  ???

If the neighbor tells me this, I have no way of knowing whether this statement is true (he might be lying to me, or be misinformed),
nor what the value of this promise is (I have never met this H-person, nor know what the YH-1 task is that's being
referred to). It's a statement made by the neighbor, about what the hairdresser promises to do, so to make it meaningful to me,
the neighbor would have to reformulate it as "I hereby vouch for the H-person's trustworthiness, and promise to force them to
perform YH-1 if you perform MN-1". But that would create a risk for the neighbor. The neighbor would then not only have to trust
me to perform MN-1, but additionally vouch for the hairdresser, so that quickly becomes unattractive.

However, in the other direction, it works better:

  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The M-person promises to [[perform task "NM-1"] if [the Y-person promises to [perform task "YM-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The N-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]

If the neighbor tells this to the hairdresser, then it's the neighbor talking what the neighbor will do, so it gives the
hairdresser an additional option to satisfy the conditions for receiving the 10 US dollars from the neighbor. Now the
hairdresser can add their own inference step:

  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  * The N-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The H-person promises to [[perform task "YH-1"] i [the Y-person promises to [perform task "YM-1"]]]

The hairdresser did discover that I (the M-person) exist, but they don't need to know how many degrees of separation there
are between you and me, and between me and the neighbor. So the hairdresser can now inform you (the Y-person) that:

  * I will cut your hair if you promise to perform task "YM-1"

In this case, there were two degrees of separation between the hairdresser and me, and a loop was found after two
participants made a local inference. But there might have been 10 degrees of separation, that led to my interest in your task
"YM-1", and another 10 that led to the neighbor's interest in my task "NM-1". There is no way
you can know conclude anything about direct connections between your peers from the hairdresser's statement by itself,
although you could time how fast the message arrived after you had your initial conversations with me and with the hairdresser,
and do some statistics to discover which of your peers seem to be more closely connected to each other on the OpenTabs network
than others. A simple random delay before forwarding an inferred statement would mean you will need to do (many) more
measurements to obtain the same amount of information about your peers, but would also make the system slower.
Suggestions for mechanisms that might mitigate this very welcome, as well as other reactions or review remarks very welcome!
Please add them on https://github.com/michielbdejong/opentabs.net-website/issues.


Conclusion
==========
OpenTabs is a system that formalizes the messages which can be exchanged to implement the search, negotiation,
commitment, and execution phase. Assuming each party has a number of contacts, and with each contact has a secure communcation
channel (including a way to check the other party's signature on cryptographically signed messages), you might imagine roughly
what the messages in each phase would look like. They would be a machine-readable version of the conversations between you, me,
the hairdresser, and the neighbor, in the examples above.

I haven't fully worked out the details of these message types yet, that will be the next phase of this projects, after I collect
feedback on the general concept of second-order promise loops, and the above description in human-language. Let me know if you're
interested in collaborating on this!

Cheers,
Michiel de Jong.

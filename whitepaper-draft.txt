LedgerLoops: Second-order promise loops

Introduction to promise loops
=============================
If everybody would only look after their own needs, the world would be a lot less efficient. It's often
useful if one person performs a task that benefits a different person. For instance, you can cook for me,
or I can fix your bicycle. A society in which everybody cooperates altruistically is hard to keep together,
because if some people only consume and don't contribute, they can easily destablize such a cooperating
society. To avoid that, apart from exchanging neutral information about what activities are needed and who
plans to do what, we can exchange promises.

A promise is a statement that has a more complex social function than simply the exchange of information.
For instance, if you say to you "You will cook for me", that sounds very different from you yourself saying
"I will cook for you". The first may in some cultures be acceptable as a command from a boss to a worker, or from a parent to
a child. The second is not a command, because you yourself make a statement about what you will do. This
statement can turn out to be true or false, but since we both automatically interpret it as a promise,
your reputation will be damaged if you don't attempt to make the statement true, that is, I will trust you
to keep your promise, or at least to try to do so.

When interpreting your promise, I can take into account several factors:

* your ethics (that is, you are not a mean person who tries to achieve personal gain by making empty promises),
* your intelligence and mental sanity (that is, you know what you're saying, speak out of your own free will,
and are unlikely to later forget what you promised),
* the difficulty of the task you promise to perform (whether you promise to do the impossible),
* related to that, your skill and ability to successfully complete the task (that is, you know how to cook,
have access to the necessary ingredients and tools, etc.),
* your reputation risk (that is, even if your ethics are questionable, or unknown to me, I can trust that you
will keep your promise based on social connections we share, and who would like you less if they found out you
made an empty promise to me),
* your third-party punishment risk (you could be arrested and punished by some government authority or mafia boss if they
notice you making empty promises to people they protect),
* your second-party retalliation risk (I could personally have more or less opportunity to punish you myself),

and probably maybe some other factors. Making a promise creates a debt, and there is always a risk in counting
on someone to keep their promise and to resolve this debt. In order to mitigate some of these risks, you and I can make
promises that are not absolute, but only applicable if some conditions are true. For instance, you could promise
"I will cook for you, if you fix my bicycle". If I then also promise "I will fix your bicycle if you will cook for me",
then we have the opportunity to barter. Once we both made our conditional promise, we can trigger both of them into
action by agreeing to both go ahead and perform the task we mentioned. Ideally, to minimize the risk even more for both
of us, we could perform our tasks at the same time, so that I can see you are at least starting to cook, and you can see I'm
starting to work on your bicycle. If, after a short time, one of us would stop investing effort in our task, then the other
person would notice, ask what the reason is, and renegotiate the barter. If we both invest into our cooperation bit-by-bit,
instead of making a big investment upfront, our exposure to the risk of the other person not keeping their promise is also
smaller.

If barter is not possible (for instance, if your bicycle is not currently broken), we can use debt to still achieve a deal
that is fair (you cook for me today because you know it will make me remember my debt when the time comes that you ask me
to fix your bicycle). If debt-based cooperation is not possible, (for instance, we're only meeting briefly and will likely return
to being strangers soon), we can use money. If you are a restaurant owner, and your bicycle is not currently broken, I might
promise to pay you in commodity money (like gold), or fiat money (like bank notes). We can also use virtual money, which is
neither commodity that has intrinsic value, nor fiat backed by a government, but instead is backed by a community of people
who happen to use this money as currency (like bitcoin or bank-of-time).

Another option, if your bicycle is not broken, but you do need a haircut, and we can find a hairdresser with a broken bicycle,
would be group barter: we agree that you cook for me, I fix the hairdresser's bicycle, and the hairdresser
cuts your hair, and all three of us gain something that is of more value to us than the effort we invest in the task we
perform for the next person in the loop. In a graph:


    your promise      > my promise                   > hairdresser's promise
          |          /      |                       /          |
          v         /       v                      /           v
    you cook for me     I fix hairdresser's bicycle     you get a haircut

In this graph, your promise creates a debt, my promise is conditional on you keeping your promise, and forwards the debt
to the hairdresser. The hairdresser then cuts your hair to eliminate the debt.

But in practice, we will probably go through three phases of discussion before we reach this group barter deal. First,
we search for people to barter with (let's call this the search phase). Once you, me, and the hairdresser found each
other, we each make our conditional promise (let's call this the negotiation phase):
* You promise to cook for me if you get a haircut from the hairdresser
* I promise to fix the hairdresser's bicycle if you cook for me
* The hairdresser promises to cut your hair if I fix their bicycle

The three conditional promises form a three-step loop in the way they refer to each other. Let's call this a
"first-order promise loop" for reasons that will become clear soon.

At this point, we can all see that there is an opportunity for cooperation, and we might negotiate exchange rates to make
the deal as fair as possible for everybody involved, adjusting maybe the amount of food you promise to cook, stating more
precisely which defects of the bicycle I promise fix, and which type of haircut you will get. Once we all agree that the
deal is fair, we can move on to the execution phase.

Ideally, we all start at the same time, so that no person needs to take more risk than the others, but this may not always be
practical (especially the combination of cooking food and getting a haircut at the same time!). This means one person (let's
call this person the "starter") needs to convert their conditional promise into an absolute promise, thereby forcing the
next promise to become absolute as well. As a logical rule of inference on the contents of my promise:
   
* I promised to:  [fix the hairdresser's bicycle] if you cook for me
* And given that:                                    You cook for me
* Conclusion:     --------------------------------------------------- +
* I should now:   [fix the hairdresser's bicycle]

But now we can notice a problem with using first-order promise loops for organizing cooperation: you may have only just
met this hairdresser, and once you cook, you now have a double risk of not obtaining your haircut: either I fail to
keep my promise, or the hairdresser fails to keep theirs. For very long first-order promise loops, the likelyhood that,
somewhere along the line, someone fails to deliver on their promise, becomes very high. Second-order
promise loops address this problem.

Second-order promise loops
==========================

After understanding the above introduction to first-order promise loops, the idea behind second-order promise loops is
in itself quite simple. The search phase is the same - you and me and the hairdresser somehow need to discover
each other, and each other's needs. But the negotiation phase is different.
Remember that in the negotiation phase for the first-order promise loop, we made the following promises:

* You promise to [[cook for me] if [you get a haircut from the hairdresser]]
* I promise to [[fix the hairdresser's bicycle] if [you cook for me]]
* The hairdresser promises to [[cut your hair] if [I fix their bicycle]]

In a second-order promise loop, we don't make our promises conditional on the other participants
*keeping* their promise, but on the other participants merely *making* their promise:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

After this negotiation phase, where we all establish and communicate our conditional promises, we can move on to the commitment
phase, where one person (the "committer") converts their conditional promise to an absolute one. Before moving on to the
execution phase, where you would actually start to cook, you first announce your decision to us that you will do so. That means
we now have one absolute promise (from you) and two conditional ones (from me and from the hairdresser):

* You promise to [cook for me]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

Now, regardless of whether you actually keep your promise, we can already apply inference to the other two promises:

* I promised to:                      [fix the hairdresser's bicycle] if [you promise to [cook for me]]
* And given that:                                                        You promised to [cook for me]
* Conclusion:                         ----------------------------------------------------------------- +
* I should now:                       [fix the hairdresser's bicycle]
* Also, the hairdresser promised to:  [cut your hair] if [I promise to [fix their bicycle]]
* And because:                                            I should now [fix their bicycle]
* Conclusion:                         ---------------------------------------------------- +
* The hairdresser should now:         [cut your hair]

The term "second-order" refers to the fact that promises are conditional on promises, so instead of one layer of promises on top
of statements about reality, we now have promises on top of promises (let us know if you can think of a better name for this!).

The advantage of second-order promise loops over first-order promise loops is, in terms of this example, that you can now claim
your haircut, even if the hairdresser's bicycle remains broken.

Promise loops and debt
======================
If you and I know each other, we don't have to settle each value exchange every time, you can just cook for me spontaneously,
and we'll both remember that debt.
This allows for a much more liquid cooperation - as long as you and I have some way to remember the contents of our private
ledger of debts between the two of us, we don't have to search for promise loops every time we want to do something for the
other person.

As long as we take care that your debt to me stays roughly equal to my debt to you (don't let the balance between us become
too uneven), we probably trust each other enough to take the risk that the other person takes off without ever repaying their
debt.
So instead of finding a hairdresser with a broken bicycle, you could say "I promise to cook for you", and I could say "If you
cook for me, then I will owe you something of comparable value", basically paying you for the cooking with an IOU note (short
for "I owe you"), signed by me.
Since it's only you and me involved, there's no need for second-order promises, a simple ledger for writing down debts will do
just fine. But the shortcoming of a two-party debt ledger is, of course, that you may want to collaborate with other specialists
(like hairdressers) to obtain the things you need. And if I owe you a debt, that does not enable you to get a haircut.

So a better way to use second-order promise loops is to combine it with peer-to-peer debt ledgers:
We write all debts in our ledger whenever one of us does something for the other person, and each of us could also have private
peer-to-peer debt ledgers with other people, with whom we interact in the same way. This means that the group barter process can
be entirely asynchronous from the actual commercial activity it negotiates. This is also where the name LedgerLoops comes from:
people keep a tab open (like a tab in a bar), and given a network of such open tabs, the LedgerLoops protocol allows participants
to search, negotiate, commit, and execute second-order promise loops that act like settlements to resolve or decrease the
outstanding amounts of debt on each ledger.

Comparison between LedgerLoops and Money
=====================================
As an LedgerLoops user, you can convert your credit with people who owe you a favor, to obtain things you need from other people.
This means that using LedgerLoops will feel like what we know as money and you could define peer-to-peer debts as some sort of
one-time coin that gets anonymized into a different currency every time it passes to the next person, but such an abstract
description probably doesn't help a lot to make the process more intuitive.

Money (whether commodity, fiat, or virtual) has two important features which peer-to-peer debts and promise loops don't:
* as long as the community using the currency in question doesn't collapse, you're pretty sure that your money will keep its
value, in the sense that, in the future there will probably be someone who will be happy to accept your money in return for
something valuable.
* for many types of money, especially cash, you don't have to reveal information about where you got the money in order to use
the money. Even when paying by creditcard in a restaurant, the restaurant owner will not discover how the money got into your
bank account (although of course your bank will). Bitcoin does not have this feature, but since for many wallets it's not
publically known which real-world person this wallet belongs to, and it's not necessary to reveal this if you're careful,
a high level of obfuscation can still be achieved there as well.

Unlike money, LedgerLoops does not form a bubble that can burst.
In LedgerLoops, the ability to find useful promise loops grows with the network size of people actively looking for such promise
loops, with the number of connections between them, and with the frequency with which users put their activities and
peer-to-peer debts up for barter.
However, and this may seem unintuitive, LedgerLoops usage can safely die and be revived in other places. It can be used in
several communities around the globe, which may stay disconnected from each other, become connected, and become disconnected
again, without risk of devaluation of people's outstanding credits and debts. This is because there is no central currency
or "bubble" of trust in the community (or its government) paying you back in the future.
At any time, you can only owe debt to your direct peers, and only they can owe debts to you. If someone defaults on their
debt, they only hurt their direct contacts, not the other participants in the network (remember that second-order promises
will still hold, even if the first-order promise they are based on is not kept).
Another way of seeing this is to say that LedgerLoops is not a form of money, it is a ledger federation protocol.

This does leave us with one important shortcoming of second-order money loops: privacy. Let's see if we can improve the
system described so far by being more careful in what personal information you and I reveal to this hairdresser person.

Keeping our details more private
================================
Remember that in the process described so far, you, me, and the hairdresser engaged in a group conversation about the
following set of conditional promises:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the hairdresser's bicycle] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [I promise to [fix their bicycle]]]

Instead of making these statements in one group conversation, we can also make them in three private conversations:

* Between you and me, conversation "YM"
  * Let's refer to "cook for me" as task "YM-1"
  * You promise to [[perform task "YM-1"] if [the hairdresser promises to [perform task "YH-1"]]]
  * I promise to [[perform task "HM-1"] if [you promise to [perform task "YM-1"]]]

* Between you and the hairdresser, conversation "YH"
  * Let's refer to "cut your hair" as task "YH-1"
  * You promise to [[perform task "YM-1"] if [the hairdresser promises to [perform task "YH-1"]]]
  * The hairdresser promises to [[perform task "YH-1"] if [I promise to [perform task "HM-1"]]]

* Between the hairdresser and me, conversation "HM"
  * Let's refer to "fix the hairdresser's bicycle" as task "HM-1"
  * The hairdresser promises to [[perform task "YH-1"] if [I promise to [perform task "HM-1"]]]
  * I promise to [[perform task "HM-1"] if [the you-person promises to [perform task "YM-1"]]]

Since you participate in both conversation "YM" and conversation "YH", you now have all the same information as in the
group conversation case, except for the nature of task "HM-1". Likewise I have all the same information except for the
nature of task "YH-1", and the hairdresser can compose all information they need to get their bike fixed in exchange
for giving you a haircut, without knowing that "YM-1" stands for you cooking me a meal. So having three separate
conversations instead of one group conversation is an improvement in terms of implementation. But we can, and should,
do better than that.

Suppose there is a fourth person involved, and the second-order promise loops looks like this:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[fix the neighbor's bicycle] if [you promise to [cook for me]]]
* The neighbor promises to [[pay the hairdresser 10 US dollars] if [I promise to [fix their bicycle]]]
* The hairdresser promises to [[cut your hair] if [the neighbor promises to [pay them 10 US dollars]]]

We can now create four conversations, hiding even more information that does not need to be shared with the whole list
of participants:

* Between you and me, conversation "YM"
  * Let's refer to "cook for me" as task "YM-1", to me as "the M-person", and to you as "the Y-person"
  * The Y-person promises to [[perform task "YM-1"] if [the H-person promises to [perform task "YH-1"]]]
  * The M-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]

* Between you and the hairdresser, conversation "YH"
  * Let's refer to "cut your hair" as task "YH-1", to you as "the Y-person", and to the hairdresser as "the H-person"
  * The Y-person promises to [[perform task "YM-1"] if [the H-person promises to [perform task "YH-1"]]]
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]

* Between the hairdresser and the neighbor, conversation "HN"
  * Let's refer to "pay 10 US dollars" as task "HN-1", to the hairdresser as "the H-person", and to the neighbor as "the N-person"
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  * The N-person promises to [[perform task "HN-1"] if [the M-person promises to [perform task "NM-1"]]]

* Between the neighbor and me, conversation "NM"
  * Let's refer to "fix the neighbor's bicycle" as task "NM-1", to me as "the M-person", and to the neighbor as "the N-person"
  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The M-person promises to [[perform task "NM-1"] if [the Y-person promises to [perform task "YM-1"]]]

Now some more information is hidden from you, so what you see is this:

* You promise to [[cook for me] if [the hairdresser promises to [cut your hair]]]
* I promise to [[perform task "NM-1"] if [you promise to [cook for me]]]
* The hairdresser promises to [[cut your hair] if [the N-person promises to [perform task "HN-1"]]]

You can no longer see if a promise loop exists or not. But each participant can see that a partial loop exists,
and inform one of their peers about this. The neighbor, after talking both to me and to the hairdresser, could make
the following local inference:

  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The H-person promises to [[perform task "YH-1"] if [The M-person promises to [perform task "NM-1"]]]

In a graph:

   ???  -YM-1->  M  -MN-1->  N  -HM-1->  H  -YH-1->  ???

becomes:

   ???  -YM-1->  M  --------MN-1-------> H  -YH-1->  ???

If the neighbor tells me this, I have no way of knowing whether this statement is true (he might be lying to me, or be misinformed),
nor what the value of this promise is (I have never met this H-person, nor know what the YH-1 task is that's being
referred to). It's a statement made by the neighbor, about what the hairdresser promises to do, so to make it meaningful to me,
the neighbor would have to reformulate it as "I hereby vouch for the H-person's trustworthiness, and promise to force them to
perform YH-1 if you perform MN-1". But that would create a risk for the neighbor. The neighbor would then not only have to trust
me to perform MN-1, but additionally vouch for the hairdresser, so that quickly becomes unattractive.

However, in the other direction, it works better:

  * The N-person promises to [[perform task "HN-1"] if [The M-person promises to [perform task "NM-1"]]]
  * The M-person promises to [[perform task "NM-1"] if [the Y-person promises to [perform task "YM-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The N-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]

If the neighbor tells this to the hairdresser, then it's the neighbor talking what the neighbor will do, so it gives the
hairdresser an additional option to satisfy the conditions for receiving the 10 US dollars from the neighbor. Now the
hairdresser can add their own inference step:

  * The H-person promises to [[perform task "YH-1"] if [the N-person promises to [perform task "HN-1"]]]
  * The N-person promises to [[perform task "HN-1"] if [the Y-person promises to [perform task "YM-1"]]]
  ------------------------------------------------------------------------------------------------------ +
  * The H-person promises to [[perform task "YH-1"] i [the Y-person promises to [perform task "YM-1"]]]

The hairdresser did discover that I (the M-person) exist, but they don't need to know how many degrees of separation there
are between you and me, and between me and the neighbor. So the hairdresser can now inform you (the Y-person) that:

  * I will cut your hair if you promise to perform task "YM-1"

In this case, there were two degrees of separation between the hairdresser and me, and a loop was found after two
participants made a local inference. But there might have been 10 degrees of separation, that led to my interest in your task
"YM-1", and another 10 that led to the neighbor's interest in my task "NM-1". There is no way
you can conclude anything about direct connections between your peers from the hairdresser's statement by itself,
although you could time how fast the message arrived after you had your initial conversations with me and with the hairdresser,
and do some statistics to discover which of your peers seem to be more closely connected to each other on the LedgerLoops network
than others. Apart from such timing attacks, the system can be made "partially anonymous", so that only your direct peers need to know
exactly who you are in real life. In fact, if we use asymmetric cryptography to check digital signatures, you only need to trust the
person who makes a promise to you, and none of the other participants in the promise loop.

Example of an LedgerLoops message sequence
=======================================

Let's get some definitions down first. These definitions will be referred to in the messages participants send, and all participants
will understand them to mean the following:

* Person: a physical person who can perform an action in the real world, who may use a computer to send messages to other persons,
and whom other persons may trust to keep their promises, whether made in natural language, or using a computer. That is, a message
sent by software running on the computer will be interpreted as intentionally sent by the person, even if the person did not explicitly
initiate the sending of the message; they gave the computer a mandate to act on their behalf by installing software on it. If a person
claims their computer sent a message which they did not want to be sent, then this will be considered as a miscommunication just like
a miscommunication caused by language barriers or human error. The two persons involved can then say sorry to each other and renegotiate
how to proceed after the miscommunication has been cleared up.

* Task: something a person can do, which might benefit another person. This could be doing work (creating new value), or giving some asset
to another person (moving the ownership of existing value around between one person to another). Tasks are identified by a hash.

* Message: a text string, sent from person A to person B, signed with a public key of which person B knows that it belongs to person A.

* Task description: A message in which person A links the identifier of a task to a description in human language, which has enough detail
so that person A and person B can agree on whether person A has successfully performed the task (to which that identifier refers), or not.

* Key publication: A message from person A to person B, containing a public key. This message is to be interpreted as follows:
  * When communicating with other persons, person B is to refer to person A by that public key, and not reveal person A's real identity
  * If a promise statement (as described below) contains a correct signature with that public key, then it will be understood (and person
    B can count on this) that promise was made by person A. This means that person A should make sure not to share the private key
    corresponding to that public key with any other person.

* Promise statement: A message from person A to person B, sent in machine-readable format, containing the following fields:
  * a public key of person A
  * a promise (as described below),
  * a correct signature, with that public key, of that promise

* Promise: A machine-readable text string (to be included in a promise statement), containing a task identifier, along with zero or more
condition statement. If (and only if) all conditions described by these condition statements have been met, the person who (in a promise
statement) signed a promise, will be indebted to do their best to succesfully perform the task identified in the promise.

* Condition statement: A machine-readable string containing a public key and a a task identifier.

* Condition: A logical predicate which can be true ("met") or false ("unmet").
Once a condition has been met, it can never become unmet again (although, of course, it can seem like it has been met, but then later
turn out to have been unmet all along, when new information arrives. When that happens, renegotation of that new situation is up to the
persons involved, and outside the scope of LedgerLoops. It is therefore important to, for instance, use strong cryptographic keying material
so that it is very unlikely that someone would be able to forge a signature.
The condition described by a condition statement has been met if, and only if:
  * The condition statement in question contains a public key and a task identifier,
  * A promise statement exists, with the same public key, a promise, and a correct signature,
  * That promise contains the same task identifier as the condition statement,
  * All conditions (if any) from that promise have themselves been met.

Note that the only way for a condition to have been met is to either refer to a promise that itself has zero conditions, or refer to
a promise, that only has conditions that refer to promises, that only have conditions that refer to promises (etc.), that eventually
only refer to promises that have zero conditions.


The following sequence of messages is roughly how a set of peer-to-peer conversations could lead to the discovery and execution of a second-order promise loop:


* You to me:
  >  Task description:
  >  I could cook for you! Would you like that?  Let's refer to 'cooking for you' as 'omZXXHOrxyk='.
  >
  >  Key publication:
  >  I created a one-time asymmetric key pair to refer to the 'me' that would (conditionally promise to) do the cooking,
  >  the public key is: 'tFijlG95+R0EV381pYl5Kw=='.
  >
  >  Anyway, let me know if you're interested! :)


* Me to the neighbor:
  >  Task description:
  >  I could fix your bicycle! Would you like that?  Let's refer to 'fixing your bicycle' as 'gUbL+BUIctY='.
  >
  >  Key publication:
  >  I created a one-time asymmetric key pair to refer to the 'me' that would (conditionally promise to) do the bicycle fixing,
  >  the public key is: '+RQ6tAsPI5FKbmd1r6eFcQ=='.
  >
  >  Also, a friend of a friend of mine suggested they could do a thing. I may not be interested in whether they actually do that thing or not,
  >  but if they were to conditionally promise to do it, and the conditions of that promise would be met, then that would eventually
  >  benefit me, through possibly some other conditional promises I'm involved in.
  >  This friend of a friend refers to that thing as 'omZXXHOrxyk=', and one of their public keys is 'tFijlG95+R0EV381pYl5Kw=='.

  >  Promise statement:
  >  > I promise, on the following condition, to perform task 'gUbL+BUIctY=':
  >  > * a promise to perform task 'omZXXHOrxyk=' exists, is correctly signed with public key 'tFijlG95+R0EV381pYl5Kw==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > '+RQ6tAsPI5FKbmd1r6eFcQ=='.


* Neighbor to hairdresser:
  >  Task description:
  >  I could give you 10 US dollars! Would you like that?  Let's refer to 'giving you 10 US dollars' as '203c2gfRsgI='.
  >
  >  Key publication:
  >  I created a one-time asymmetric key pair to refer to the 'me' that would (conditionally promise to) give you the 10 US dollars,
  >  the public key is: 'xuSctraZJQSWocI4LwFjJQ=='.
  >
  >  Also, several people suggested they could do a thing. I may not be interested in whether they actually do that thing or not,
  >  but if they were to conditionally promise to do it, and the conditions of that promise would be met, then that would eventually
  >  benefit me, through possibly some other conditional promises I'm involved in.
  >  One of them refers to their thing as 'omZXXHOrxyk=', and has public key 'tFijlG95+R0EV381pYl5Kw=='.
  >  The other refers to their thing as 'gUbL+BUIctY=', and has public key '+RQ6tAsPI5FKbmd1r6eFcQ=='.

  >  Promise statement 1:
  >  > I promise, on the following condition, to perform task '203c2gfRsgI=':
  >  > * a promise to perform task 'omZXXHOrxyk=' exists, is correctly signed with public key 'tFijlG95+R0EV381pYl5Kw==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > 'xuSctraZJQSWocI4LwFjJQ=='.

  >  Promise statement 2:
  >  > I promise, on the following condition, to perform task '203c2gfRsgI=':
  >  > * a promise to perform task 'gUbL+BUIctY=' exists, is correctly signed with public key '+RQ6tAsPI5FKbmd1r6eFcQ==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > 'xuSctraZJQSWocI4LwFjJQ=='.

* Hairdresser to you:
  >  Task description:
  >  I could cut your hair! Would you like that?  Let's refer to 'cutting your hair' as 'JWkyqz02PPU='.
  >
  >  Key publication:
  >  I created a one-time asymmetric key pair to refer to the 'me' that would (conditionally promise to) cut your hair,
  >  the public key is: 'PbG/84/lk2yoWUEK23fbjQ=='.
  >
  >  Also, several people suggested they could do a thing. I may not be interested in whether they actually do that thing or not,
  >  but if they were to conditionally promise to do it, and the conditions of that promise would be met, then that would eventually
  >  benefit me, through possibly some other conditional promises I'm involved in.
  >  One of them refers to their thing as 'omZXXHOrxyk=', and has public key 'tFijlG95+R0EV381pYl5Kw=='.
  >  Another refers to their thing as 'gUbL+BUIctY=', and has public key '+RQ6tAsPI5FKbmd1r6eFcQ=='.
  >  Yet another refers to their thing as '203c2gfRsgI=', and has public key 'xuSctraZJQSWocI4LwFjJQ=='.

  >  Promise statement 1:
  >  > I promise, on the following condition, to perform task 'JWkyqz02PPU=':
  >  > * a promise to perform task 'omZXXHOrxyk=' exists, is correctly signed with public key 'tFijlG95+R0EV381pYl5Kw==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.

  >  Promise statement 2:
  >  > I promise, on the following condition, to perform task 'JWkyqz02PPU=':
  >  > * a promise to perform task 'gUbL+BUIctY=' exists, is correctly signed with public key '+RQ6tAsPI5FKbmd1r6eFcQ==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.

  >  Promise statement 3:
  >  > I promise, on the following condition, to perform task 'JWkyqz02PPU=':
  >  > * a promise to perform task '203c2gfRsgI=' exists, is correctly signed with public key 'xuSctraZJQSWocI4LwFjJQ==',
  >  >   and that promise is either unconditional, or all of its conditions have been met.
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.

Note that the condition of promise statement 1 there, unbeknown to the hairdresser, refers to you cooking for me! You're more then
willing to cook for me if that allows you to meet the hairdresser's condition for the haircut, so your respond:

* You to hairdresser:
  >  I can hereby prove that the condition for your promise statement 1 has been met, look at this quote from a signed statement
  >  by some friend of a friend of mine:
  >
  >  > I hereby promise to perform task 'JWkyqz02PPU=':
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.
  >
  >  As you can see, the signature is correct, so please cut my hair!


* Hairdresser to neighbor:
  >  I can hereby prove that the condition for your promise statement 1 has been met, look at this quote from a signed statement
  >  by some friend of a friend of mine:
  >
  >  > I hereby promise to perform task 'JWkyqz02PPU=':
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.
  >
  >  As you can see, the signature is correct, so please give me the 10 US dollars!

* Neighbor to me:
  >  I can hereby prove that the condition for your promise statement 1 has been met, look at this quote from a signed statement
  >  by some friend of a friend of mine:
  >
  >  > I hereby promise to perform task 'JWkyqz02PPU=':
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.
  >
  >  As you can see, the signature is correct, so please give fix my bicycle!

* Me to you:
  >  Hey, a friend of a friend of mine just quoted an unconditional promise which caught my eye:
  >
  >  > I hereby promise to perform task 'JWkyqz02PPU=':
  >  > Signed,
  >  > <signature>
  >  > 'PbG/84/lk2yoWUEK23fbjQ=='.
  >
  >  As you can see, the signature is correct, so it was you, right? Thanks! Looking forward to you cooking for me! :)

After tasks have been completed, it would probably make sense for the benefitting person to send a receipt to the person who
completed the task, so that there can be no confusion, for instance a year later, whether a promise was already fullfilled,
or is still outstanding. Promises should also probably have an expiry date, especially when offering unique items. From the
moment I offer you the painting from my living room in exchange for something else, I need to reserve that painting in case
a deal is reached (a promise loop is found), and you claim the painting from me. However, if no promise loop is found within
a few days, I probably don't want to keep it reserved forever, I would want to try offering it to someone else next week.

It would also make sense to have a message format for promise statements with multiple lists of condition statements (instead
of persons sending 2 or 3 or more separate promise statements about the same task).

Finally, apart from timing attacks, in the example above, it would be easy for the neighbor to conclude that I benefit from task
'JWkyqz02PPU=' directly, and therefore probably have a close connection to person 'PbG/84/lk2yoWUEK23fbjQ=='.
them directly. Therefore, a person (or their software tool) may introduce fake condition lists in a promise statement, to obfuscate
which one of the condition lists would benefit the person directly.

Suggestions for mechanisms that might mitigate timing attacks to reveal network structure would be very welcome, as well as suggestions
for a better name for "second-order promise loop", and other reactions or review remarks!

There are possible several more such improvements that can be made, and other issues that will come up once we try to implement the
basic parts of a software tool for the protocol described, and dig deeper into the details and dynamics.

Improvements to this whitepaper-draft are currently being tracked on https://github.com/michielbdejong/ledgerloops/issues.
Thanks a lot for reading this far, please join the discussion there!


Cheers,
Michiel de Jong.
